#!/bin/bash
#
#   I N I C E R T O   incertidumbre disl√©xica - dyslexic uncertainty
#
# Try to simplify multiple signed certificate generation by a simple CA
# that provides signed certificates and they corresponding private keys.
# WARNING This is not the normal operation of a certificate authority.
# It is best suited for internal use only or when you control all endpoints.
# Use at your own risk.
# WARNING passwords could be viewed temporally in command line process view
# TODO: See if openssl ca could be a better fit for your use case.
#
# Author: Vicente Jimenez Aguilar <googuy@gmail.com>
#
# backronyms:
# sIgNIng CERTificates Only
# INternal CERTificates Only
# Inicerto Not Incierto CERTificates Only
# Inicerto Not Incierto Certificate Easy Release Tool Only
# TODO: you can do better

if [ -z "$1" ]; then
	printf "Usage:
  $0 'CA name to use' [dns.fqdn]

    At least a certificate authority name must be provided.
    Creates new private key and self signed CA certificate if they are missing.

    dns.fqdn parameter is optional. When provided it tries to create
    a private key and its corresponding certificate signed by the named CA.
"
	exit 1
fi

CA="$1"
FQDN="$2"

askpass() {
	read -rsp "$1" "$2"
	echo
}

if [ -r "${CA}.key" ]; then
	while : ; do
		askpass "Enter current ${CA} key password: " CAKEY
		if openssl rsa -in "${CA}.key" -passin "pass:$CAKEY" \
			-noout 2> /dev/null; then
			break
		fi
		printf "Password for ${CA} key is incorrect\n"
	done
	if [ ! -r "${CA}.crt" ]; then
		# Create a self signed CA certificate from an existing key
		openssl req -new -x509 -key "${CA}.key" -passin "pass:$CAKEY" \
			-days 1461 -out "${CA}.crt"
	fi
else
	while : ; do
		askpass "Enter desired ${CA} key password: " CAKEY
		askpass "Re-type ${CA} key password: " CAKEY2
		if [ "$CAKEY" == "$CAKEY2" ]; then
			break
		fi
		printf 'Passwords do not match. Try again.\n'
	done
	# Create a self signed CA certificate and key
	openssl req -new -x509 -newkey rsa:4096 \
		-keyout "${CA}.key" -passout "pass:$CAKEY" \
		-days 1461 -out "${CA}.crt"
fi

if [ ! -r "${CA}.p12" -a -r "${CA}.crt" ]; then
	# FIXME find a way to create a PKCS12 truststore without using keytool
	# openssl pkcs12 -export -nokeys -in "${CA}.crt" -caname "${CA} name" \
	#         -out truststore.p12
	# Creates a PKCS12 keystore containing a single CA certificate
	# with a friendlyName but no 2.16.840.1.113894.746875.1.1 bag attribute
	# so keytool does not find any entry
	# https://github.com/openssl/openssl/issues/6684
	# Apparently this OID is required for trustedCertEntry in Java
	# https://www.jhack.it/mediaWiki/index.php/OpenSSL&Co#Trusted_certificates_in_PKCS.2312.2FP12.2FPFX
	# FIXME Avoid executing keytool if not present
	keytool -importcert -file "${CA}.crt" -alias "${CA} certificate" \
		-keystore "${CA}.p12"
fi

if [ -r "${CA}.key" -a -r "${CA}.crt" -a "$FQDN" ]; then
	printf 'Creating a new private key and a signed certificate for %s\n' \
		"$FQDN"
	while : ; do
		askpass "Enter desired ${FQDN} key password: " DNKEY
		askpass "Re-type ${FQDN} key password: " DNKEY2
		if [ "$DNKEY" == "$DNKEY2" ]; then
			break
		fi
		printf 'Passwords do not match. Try again.\n'
	done
	# Get subject from CA certificate but replaces CN value with %s
	SUBJ="$(
		openssl x509 -in "${CA}.crt" -noout -subject |
		sed 's/\(subject=\|, \)\([A-Z]*\) = /\/\2=/g; s/CN=[^/]*/CN=%s/'
		)"
	SAN="subjectAltName = DNS:${FQDN}"
	# About Extensions
	# ----------------
	# Maybe extendedKeyUsage=serverAuth needs to be added
	#
	# OpenSSL has no option to copy request extensions into certificate
	# so -addext request option could be removed
	# openssl x509 command could only get extensions from a file
	# So to avoid writing a file we use <() bashism
	# This could be replaced using a temporary file
	openssl req -new -subj "$( printf "$SUBJ" "$FQDN" )" -addext "$SAN" \
		-newkey rsa:4096 -keyout "${FQDN}.key" -passout "pass:$DNKEY" |
	openssl x509 -req -CA "${CA}.crt" \
		-CAkey "${CA}.key" -passin "pass:$CAKEY" -CAcreateserial \
		-extfile <( echo "$SAN" ) -days 366 -out "${FQDN}.crt"
	printf \
	'Creating %s PKCS12 container with key and certificate chain for %s\n' \
	"$FQDN.p12" "$FQDN"
	# FIXME openssl favor compatibility over security for PKCS12 by default
	# because PKCS12 is mainly use for credential transmission
	# so default values are not very secure
	# low iteration counts and 3DES usage for example
	openssl pkcs12 -export -in "${FQDN}.crt" -name "${FQDN} certificate" \
		-inkey "${FQDN}.key" -passin "pass:$DNKEY" \
		-certfile "${CA}.crt" -caname "${CA} certificate" \
		-out "${FQDN}.p12" -passout "pass:$DNKEY" 
	if [ -r "${CA}.srl" ]; then
		COPY="${FQDN}.$( cat "${CA}.srl" )"
		printf 'Making file copies with serial number in their name\n'
		for EXT in key crt p12; do
			FROM="${FQDN}.${EXT}"
			TO="${COPY}.${EXT}"
			cp -a "$FROM" "$TO" && \
				printf '  %s = %s\n' "$FROM" "$TO"
		done
	fi
fi
